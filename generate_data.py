# Assignment 1 - Exercise (a) #
# Author: Konstantinos Garas
# E-mail: kgaras041@gmail.com // k.gkaras@student.rug.nl
# Created: Sat 29 Dec 2025 @ 11:34:07 +0100
# Modified: Mon 01 Dec 2025 @ 13:20:36 +0100

# Packages
import numpy as np
from pathlib import Path

def main():
    num_samples = 200
    dim = 20
    seed = None
    path = Path("data/dataset.csv")

    X, y = generate_dataset(num_samples, dim, seed)

    # Sanity Checks
    print(f"Generated dataset with P = {num_samples}, N = {dim}")
    print("First 5 feature vectors:")
    print(X[:5])
    print("First 5 labels:")
    print(y[:5])

    if path is not None:
        save_as_csv(X, y, path)

def generate_dataset(num_samples: int, dim: int, seed: int | None = None):
    """
    This function generates an artificial data set according to the instructions
    given in exercise (a) of the first assignment. More specifically, it
    generates N-dimensional feature vectors with 0 mean and 1 variance, as well
    as binary labels chosen randomly, but equally, from {+1, -1}.

    Args:
        num_samples : int
            Number of patterns P
        dim : int
            Dimension of each pattern (length of the vector array)
        seed: int or None
            Optional random seed for reproducability of the dataset

    Returns:
        X : np.ndarrray, shape (P, N)
            Storage matrix for the feature vectors
        y : np.ndarray, shape (P,)
            Binary labels chosen equally from {+1, -1}
    """
    # Lady Luck accept this hubris
    rng = np.random.default_rng(seed)

    # Features are chosen according to the Normal distribution N(0,1) for simpli-
    # city
    X = rng.normal(loc = 0.0, scale = 1.0, size = (num_samples, dim))

    # Labels are chosen from {+1, -1} with probability 1/2 each
    y = rng.choice([1, -1], size = num_samples)

    return X, y

def save_as_csv(X: np.ndarray, y: np.ndarray, path: Path) -> None:
    """
    This is a helper function that saves a dataset of vectors and labels
    generated by 'generate_dataset' into a .CSV file for the purposes of 
    reproducing the results. It might not be used, but it is good that it exists.

    Args:
        X : np.ndarray, shape (P, N)
            Storage matrix for the feature vectors
        y : np.ndarray, shape (P,)
            Binary labels chosen equally from {+1, -1}
        path : Path
            The location where to save the .csv file

    Returns:
        None. The saved file will have N feature columns (xi_0, ..., xi_{N-1})
        and one label column ('label'). This format is standard practice in data
        science applications.
    """
    # Resolve absolute paths, e.g. ~/data/set.csv -> /home/user/data/set.csv (in
    # Linux), I don't know what this does on Windows.
    path = path.expanduser().resolve()

    # Reshape y from (P,) to (P, 1) so it can be stacked horizontaly as a column
    data = np.hstack([X, y[:, None]])

    # X.shape is (P, N), this fetches N (length of feature vectors)
    dim = X.shape[1]

    # Create a column header for each feature \xi_j. Range goes from (0, N-1) and
    # then append the "label" name for the last column.
    header_cols = [f"x{j}" for j in range(dim)] + ["label"]

    # Join the columns into a single string, separated by commas
    header = ",".join(header_cols)

    # Writes the array to a text file in path. The delimiter="," makes the file
    # a CSV. Comments="" is necessary to avoid '#' letter according to the docs.
    np.savetxt(path, data, delimiter=",", header=header, comments="")

    # Sanity checks
    print(f"Saved dataset to {path}")
    print(f"Shape: X {X.shape}, y {y.shape}")

if __name__ == "__main__":
    main()
